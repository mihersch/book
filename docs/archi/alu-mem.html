<!doctype html>
<html class="no-js" lang="fr">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Recherche" href="../search.html" /><link rel="next" title="5. Architecture générale et composants" href="archi-gen.html" /><link rel="prev" title="3. Additionneur" href="additionneur.html" />

    <link rel="shortcut icon" href="../_static/modulo-icon.ico"/><meta name="generator" content="sphinx-4.2.0, furo 2021.10.09"/>
        <title>4. ALU et mémoire - Apprendre</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=0254c309f5cadf746f1a613e7677379ac9c8cdcd" />
    <link rel="stylesheet" type="text/css" href="../_static/codeplay.css" />
    <link rel="stylesheet" type="text/css" href="../_static/glossary.css" />
    <link rel="stylesheet" type="text/css" href="../_static/questions.css" />
    <link rel="stylesheet" type="text/css" href="../_static/videos.css" />
    <link rel="stylesheet" type="text/css" href="../_static/logic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/blanks.css" />
    <link rel="stylesheet" type="text/css" href="../_static/timeline.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=16fb25fabf47304eee183a5e9af80b1ba98259b1" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/global.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/reactions.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/progress.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  --font-stack: Montserrat, system-ui, -apple-system, BlinkMacSystemFont,"Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --color-foreground-primary: black;
  --color-foreground-secondary: #5a5c63;
  --color-foreground-muted: #646776;
  --color-foreground-border: #878787;
  --color-background-primary: white;
  --color-background-secondary: #f8f9fb;
  --color-background-hover: #efeff4ff;
  --color-background-over--transparent: #efeff400;
  --color-background-border: #eeebee;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: #5933D1;
  --color-brand-content: #5933D1;
  --admonition-font-size: 0.9rem;
  --admonition-title-font-size: 0.9rem;
  
  }
  body[data-theme="dark"] {
    --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --font-stack: Montserrat, system-ui, -apple-system, BlinkMacSystemFont,"Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --color-foreground-primary: #ffffffcc;
  --color-foreground-secondary: #9ca0a5;
  --color-foreground-muted: #81868d;
  --color-foreground-border: #666666;
  --color-background-primary: #131416;
  --color-background-secondary: #131416;
  --color-background-hover: #1e2124ff;
  --color-background-over--transparent: #1e212400;
  --color-background-border: #303335;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: #7C3EFF;
  --color-brand-content: #7C3EFF;
  --admonition-font-size: 0.9rem;
  --admonition-title-font-size: 0.9rem;
  
  }
  @media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  --font-stack: Montserrat, system-ui, -apple-system, BlinkMacSystemFont,"Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif,"Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --color-foreground-primary: #ffffffcc;
  --color-foreground-secondary: #9ca0a5;
  --color-foreground-muted: #81868d;
  --color-foreground-border: #666666;
  --color-background-primary: #131416;
  --color-background-secondary: #131416;
  --color-background-hover: #1e2124ff;
  --color-background-over--transparent: #1e212400;
  --color-background-border: #303335;
  --color-announcement-background: #000000dd;
  --color-announcement-text: #eeebee;
  --color-brand-primary: #7C3EFF;
  --color-brand-content: #7C3EFF;
  --admonition-font-size: 0.9rem;
  --admonition-title-font-size: 0.9rem;
  
    }
  }
</style></head>
  <body>
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path stroke="none" d="M0 0h24v24H0z" />
      <line x1="4" y1="6" x2="20" y2="6" />
      <line x1="10" y1="12" x2="20" y2="12" />
      <line x1="6" y1="18" x2="20" y2="18" />
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">Apprendre</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../_static/modulo-logo-light.svg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../_static/modulo-logo-dark.svg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">Apprendre</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Recherche name="q" aria-label="Recherche">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Première année</span></p>
<ul class="current">
<li class="toctree-l1 has-children"><a class="reference internal" href="../rep-info/index.html">Représentation de l’information</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/entiers.html">2. Les entiers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/caracteres.html">3. Les caractères</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/images.html">4. Les images</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/son.html">5. Le son</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/redondance.html">6. Redondance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rep-info/conclusion.html">7. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../prog1/index.html">Programmation I</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../prog1/dessiner.html">1. Dessiner - <code class="docutils literal notranslate"><span class="pre">forward()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/definir.html">2. Définir - <code class="docutils literal notranslate"><span class="pre">def</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/colorier.html">3. Colorier - <code class="docutils literal notranslate"><span class="pre">color()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/repeter.html">4. Répéter - <code class="docutils literal notranslate"><span class="pre">for</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/cercler.html">5. Cercler - <code class="docutils literal notranslate"><span class="pre">circle()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/memoriser.html">6. Mémoriser - <code class="docutils literal notranslate"><span class="pre">a=100</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/parcourir.html">7. Parcourir - <code class="docutils literal notranslate"><span class="pre">tuple</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/write.html">8. Typographier - <code class="docutils literal notranslate"><span class="pre">write()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/iterer.html">9. Itérer - <code class="docutils literal notranslate"><span class="pre">range()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/parametrer.html">10. Paramétrer - <code class="docutils literal notranslate"><span class="pre">f(x)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/randomiser.html">11. Randomiser - <code class="docutils literal notranslate"><span class="pre">random</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/questionner.html">12. Questionner - <code class="docutils literal notranslate"><span class="pre">input()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/decider.html">13. Décider - <code class="docutils literal notranslate"><span class="pre">if</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/ecrire.html">14. Ecrire - <code class="docutils literal notranslate"><span class="pre">str</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/attendre.html">15. Attendre - <code class="docutils literal notranslate"><span class="pre">while</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/renvoyer.html">16. Renvoyer - <code class="docutils literal notranslate"><span class="pre">return</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/grouper.html">17. Grouper - <code class="docutils literal notranslate"><span class="pre">list</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/trier.html">18. Trier - <code class="docutils literal notranslate"><span class="pre">sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/turtleart.html">19. TurtleArt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/projet.html">20. Projet</a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog1/annexe.html">21. Annexes</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../algo1/index.html">Algorithmique I</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../algo1/intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo1/algorithmes.html">2. Les algorithmes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo1/tri.html">3. Trie, cherche et trouve</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo1/algo-progs.html">4. Des algorithmes aux programmes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo1/conclusion.html">5. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Architecture des ordinateurs</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="sys-log.html">2. Portes logiques</a></li>
<li class="toctree-l2"><a class="reference internal" href="additionneur.html">3. Additionneur</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">4. ALU et mémoire</a></li>
<li class="toctree-l2"><a class="reference internal" href="archi-gen.html">5. Architecture générale et composants</a></li>
<li class="toctree-l2"><a class="reference internal" href="micro-pro.html">6. Le microprocesseur</a></li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">7. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../hist/index.html">Histoire de l’informatique</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../hist/main1.html">1. Histoire de l’informatique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/main1.html#une-breve-histoire-de-linformatique">2. Une (brève) histoire de l’informatique</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/portraits.html">3. Galerie de portraits</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/jeuxvideo.html">4. Brève histoire des jeux vidéo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/machines.html">5. Histoire des machines</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/notions.html">6. Notions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/technologies.html">7. Technologies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hist/entreprises.html">8. Entreprises</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deuxième année</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../algo2/index.html">Algorithmique II</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../algo2/intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/complexite.html">2. Complexité des algorithmes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/recherche.html">3. Algorithmes de recherche</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/tris.html">4. Algorithmes de tri</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/heuristiques.html">5. Solutions heuristiques</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/recursivite.html">6. Récursivité [en option]</a></li>
<li class="toctree-l2"><a class="reference internal" href="../algo2/conclusion.html">7. Conclusion</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../prog2/index.html">Programmation II</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../prog2/onkey.html">1. Déclencher - <code class="docutils literal notranslate"><span class="pre">onkey()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/lambda.html">2. Formaliser - <code class="docutils literal notranslate"><span class="pre">lambda</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/onclick.html">3. Cliquer - <code class="docutils literal notranslate"><span class="pre">onclick()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/ontimer.html">4. Interrompre - <code class="docutils literal notranslate"><span class="pre">ontimer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/turtle.html">5. Cloner - <code class="docutils literal notranslate"><span class="pre">Turtle</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/class.html">6. Créer - <code class="docutils literal notranslate"><span class="pre">class</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/inherit.html">7. Hériter - <code class="docutils literal notranslate"><span class="pre">E(P)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/math.html">8. Tracer - <code class="docutils literal notranslate"><span class="pre">math</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/dict.html">9. Associer - <code class="docutils literal notranslate"><span class="pre">dict</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/compter.html">10. Compter - <code class="docutils literal notranslate"><span class="pre">bin</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/color.html">11. Nuancer - <code class="docutils literal notranslate"><span class="pre">color</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/set.html">12. Appartenir - <code class="docutils literal notranslate"><span class="pre">set</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/bool.html">13. Raisonner - <code class="docutils literal notranslate"><span class="pre">bool</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/bit.html">14. Manipuler - <code class="docutils literal notranslate"><span class="pre">&amp;</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/recursif.html">15. Revenir - <code class="docutils literal notranslate"><span class="pre">f(n)</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/vector.html">16. Vecteurs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/force.html">17. Forces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../prog2/idees.html">18. Idées</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../projets/index.html">Projets</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../projets/tic_tac_toe.html">1. Tic-tac-toe</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/puissance4.html">2. Puissance 4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/mines.html">3. Démineur</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/snake.html">4. Snake</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/game_of_life.html">5. Game of life</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/cartes.html">6. Poker</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/tetris.html">7. Tetris</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/art_absurde.html">8. Art absurde</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/microbit/microbit.html">9. Micro:bit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/crypto.html">10. Cryptographie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../projets/idees.html">11. Idées</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../resx/index.html">Réseaux</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../resx/intro.html">1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resx/adressage.html">2. Adressage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resx/tcp-ip.html">3. Paquets et protocoles</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resx/routage.html">4. Routage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resx/web.html">5. Le World Wide Web</a></li>
<li class="toctree-l2"><a class="reference internal" href="../resx/couches.html">6. Interopérabilité</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Outils</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../glossaire.html">Glossaire</a></li>
</ul>

</div>
</div>
      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="alu-et-memoire">
<h1><span class="section-number">4. </span>ALU et mémoire<a class="headerlink" href="#alu-et-memoire" title="Lien permanent vers ce titre">¶</a></h1>
<p>Dans cette section, nous continuons notre exploration de comment les portes logiques, selon leur assemblage, fournissent les fonctionnalités de base des ordinateurs. En particulier, nous nous intéressons à comment faire effectuer plusieurs opérations à un ordinateur via ce qui s’appelle une unité arithmétique et logique, puis nous voyons comment l’ordinateur se rappelle les résultats des calculs intermédiaires via des bascules.</p>
<section id="unite-arithmetique-et-logique">
<h2>Unité arithmétique et logique<a class="headerlink" href="#unite-arithmetique-et-logique" title="Lien permanent vers ce titre">¶</a></h2>
<p>Dans la section précédente, nous avons vu comment créer, via un assemblage de portes logiques, un circuit qui réalise l’addition de deux nombres de 4 bits. Ce circuit était fixe : avec les deux nombres d’entrées, il réalisait toujours une addition et ne servait ainsi qu’à ça.</p>
<p>Les ordinateurs ont la propriété d’être programmables : ils savent effectuer plusieurs opérations, et c’est la manière dont ils sont programmés qui va déterminer l’opération qu’ils effectuent. C’est aussi vrai pour des machines plus simples ; une calculatrice de poche, par exemple, pourra effectuer au moins les quatre opérations de base : addition, soustraction, multiplication et division.</p>
<p>Le composant qui nous permettra de sélectionner une opération ou une autre s’appelle « unité arithmétique et logique », communément appelé simplement « ALU » (de l’anglais <em>arithmetic logic unit</em>). Avant d’inspecter une ALU, nous avons besoin de comprendre comment on peut sélectionner une opération ou une autre avec des circuits logiques.</p>
<section id="selection-de-loperation">
<h3>Sélection de l’opération<a class="headerlink" href="#selection-de-loperation" title="Lien permanent vers ce titre">¶</a></h3>
<p>Comment créer un circuit qui permet de sélectionner une opération à faire, et comment indiquer l’opération à sélectionner ? Essayons d’abord de créer un circuit à deux entrées qui va calculer soit le <strong>OU</strong> soit le <strong>ET</strong> de ces deux entrées.</p>
<p>Nous savons faire un circuit simple qui calcule le <strong>OU</strong> de deux entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span>, avec une seule porte logique :</p>
<div class="logic-container" style="height: 140px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 0, "name": "X", "val": 0},
    {"pos": [50, 110], "id": 1, "name": "Y", "val": 0}
  ],
  "gates": [{"type": "OR", "pos": [180, 40], "in": [6, 7], "out": 8}],
  "out": [{"pos": [250, 40], "id": 2, "name": "X OU Y"}],
  "wires": [[0, 6], [1, 7], [8, 2]]
}
</script></logic-editor></div><p>Nous pouvons sans autre y ajouter une porte <strong>ET</strong> pour calculer une autre sortie en parallèle, à partir des mêmes entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span> :</p>
<div class="logic-container" style="height: 140px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 0, "name": "X", "val": 0},
    {"pos": [50, 110], "id": 1, "name": "Y", "val": 0}
  ],
  "gates": [
    {"type": "OR", "pos": [180, 40], "in": [6, 7], "out": 8},
    {"type": "AND", "pos": [180, 100], "in": [3, 4], "out": 5}
  ],
  "out": [
    {"pos": [250, 40], "id": 2, "name": "X OU Y"},
    {"pos": [250, 100], "id": 9, "name": "X ET Y"}
  ],
  "wires": [[0, 6], [1, 7], [8, 2], [0, 3], [1, 4], [5, 9]]
}
</script></logic-editor></div><p>L’idée est maintenant de combiner ces sorties intermédiaires pour n’en avoir plus qu’une, qui sera soit le <strong>OU</strong>, soit le <strong>ET</strong>. Mais comment faire pour indiquer si l’on désire le <strong>OU</strong> ou le <strong>ET</strong> ? Nous pouvons rajouter une entrée pour choisir cette opération. Appelons-la <span class="math notranslate nohighlight">\(Op\)</span>, pour « opération ». Choisissons une convention : lorsque <span class="math notranslate nohighlight">\(Op\)</span> vaut 0, nous souhaitons effectuer l’opération <strong>OU</strong>, et lorsque <span class="math notranslate nohighlight">\(Op\)</span> vaut 1, nous souhaitons effectuer l’opération <strong>ET</strong>. Conceptuellement, il nous faut donc compléter ce schéma pour calculer notre sortie finale <span class="math notranslate nohighlight">\(Z\)</span> en fonction de <span class="math notranslate nohighlight">\(Op\)</span> :</p>
<div class="logic-container" style="height: 300px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "opts": {"showDisconnectedPins": true},
  "in": [
    {"pos": [50, 170], "id": 0, "name": "X", "val": 0},
    {"pos": [50, 250], "id": 1, "name": "Y", "val": 0},
    {"pos": [260, 50], "orient": "s", "id": 2, "name": "Op", "val": 0}
  ],
  "out": [
    {"pos": [440, 200], "id": 20, "name": "Z"},
    {"pos": [250, 240], "id": 21, "name": "X ET Y"},
    {"pos": [250, 180], "id": 23, "name": "X OU Y"}
  ],
  "gates": [
    {"type": "AND", "pos": [180, 240], "in": [3, 4], "out": 5},
    {"type": "OR", "pos": [180, 180], "in": [6, 7], "out": 8}
  ],
  "wires": [[0, 3], [1, 4], [0, 6], [1, 7], [5, 21], [8, 23]]
}
</script></logic-editor></div><p>Pour la suite, nous avons besoin de nous rappeler ceci. Lorsqu’un signal, disons <span class="math notranslate nohighlight">\(A\)</span>, passe à travers une porte logique <strong>ET</strong> dont la seconde entrée vaut 0, la sortie de cette porte-là sera toujours identique à 0. Cela nous permet ainsi d’annuler le signal <span class="math notranslate nohighlight">\(A\)</span>. De manière similaire, si cette seconde entrée vaut 1, le signal <span class="math notranslate nohighlight">\(A\)</span> passera tel quel. On peut ainsi voir la porte <strong>ET</strong> comme un annulateur de signal. Vérifiez ceci ici :</p>
<!-- TODO the aux inputs constant once we can in the simulator and remove their names -->
<div class="logic-container" style="height: 190px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 40], "id": 0, "name": "A", "val": 0},
    {"pos": [50, 130], "id": 1, "name": "A'", "val": 0},
    {"pos": [130, 150], "id": 2, "name": "1", "val": 1},
    {"pos": [130, 60], "id": 7, "name": "0", "val": 0}
  ],
  "out": [
    {"pos": [270, 50], "id": 8, "name": "A annulé"},
    {"pos": [270, 140], "id": 12, "name": "A' tel quel"}
  ],
  "gates": [
    {"type": "AND", "pos": [200, 50], "in": [4, 5], "out": 6},
    {"type": "AND", "pos": [200, 140], "in": [9, 10], "out": 11}
  ],
  "wires": [[0, 4], [7, 5], [6, 8], [1, 9], [2, 10], [11, 12]]
}
</script></logic-editor></div><p>Ensuite, lorsqu’un signal, disons <span class="math notranslate nohighlight">\(B\)</span> cette fois, passe à travers une porte logique <strong>OU</strong> dont la seconde entrée est annulée et vaut 0, la sortie de cette porte sera toujours identique à <span class="math notranslate nohighlight">\(B\)</span>. Vérifiez ceci ici :</p>
<div class="logic-container" style="height: 80px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 1, "name": "B", "val": 0},
    {"pos": [130, 50], "id": 2, "name": "0", "val": 0}
  ],
  "out": [{"pos": [270, 40], "id": 12, "name": "B tel quel"}],
  "gates": [{"type": "OR", "pos": [200, 40], "in": [9, 10], "out": 11}],
  "wires": [[1, 9], [2, 10], [11, 12]]
}
</script></logic-editor></div><p>La porte <strong>OU</strong> peut ainsi servir à combiner deux signaux, pour autant que l’un soit annulé.</p>
<p>Avec tout ceci, on peut ainsi construire un sélecteur de signal. Supposons qu’on ait les deux signaux <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span> : nous pouvons construire un circuit qui combine soit <span class="math notranslate nohighlight">\(A\)</span> tel quel et <span class="math notranslate nohighlight">\(B\)</span> annulé, soit <span class="math notranslate nohighlight">\(A\)</span> annulé et <span class="math notranslate nohighlight">\(B\)</span> tel quel. Cela nous aidera pour notre projet initial ! Il faut cependant s’assurer que <span class="math notranslate nohighlight">\(A\)</span> soit chaque fois annulé quand <span class="math notranslate nohighlight">\(B\)</span> passe tel quel, et inversement. Ceci peut se faire en réutilisant l’idée d’une entrée de contrôle <span class="math notranslate nohighlight">\(Op\)</span> ainsi. Nous avons ainsi deux cas :</p>
<ul class="simple">
<li><p>Lorsque <span class="math notranslate nohighlight">\(Op = 0\)</span>, on va sélectionner <span class="math notranslate nohighlight">\(A\)</span> et annuler <span class="math notranslate nohighlight">\(B\)</span>. On va donc faire passer <span class="math notranslate nohighlight">\(A\)</span> à travers une porte <strong>ET</strong> à laquelle on donne 1 à l’autre entrée, et faire passer <span class="math notranslate nohighlight">\(B\)</span> à travers une porte <strong>ET</strong> à laquelle on donne 0 à la seconde entrée.</p></li>
<li><p>Lorsque <span class="math notranslate nohighlight">\(Op = 1\)</span>, on va faire exactement l’inverse: sélectionner <span class="math notranslate nohighlight">\(B\)</span> et annuler <span class="math notranslate nohighlight">\(A\)</span>. On donnera donc un 0 à la porte <strong>ET</strong> qui filtre <span class="math notranslate nohighlight">\(A\)</span>, et 1 à la porte <strong>ET</strong> qui filtre <span class="math notranslate nohighlight">\(B\)</span>.</p></li>
</ul>
<p>En relisant ces lignes, on voit que ce qu’on donne à la seconde entrée de la porte qui filtre <span class="math notranslate nohighlight">\(B\)</span> est toujours la même chose que <span class="math notranslate nohighlight">\(Op\)</span>, et que ce qu’on donne à la seconde entrée de la porte qui filtre <span class="math notranslate nohighlight">\(A\)</span> est toujours l’inverse de <span class="math notranslate nohighlight">\(Op\)</span>. On peut donc construire ce circuit avec un inverseur en plus :</p>
<div class="logic-container" style="height: 290px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 180], "id": 0, "name": "A", "val": 0},
    {"pos": [50, 240], "id": 1, "name": "B", "val": 0},
    {"pos": [130, 50], "orient": "s", "id": 2, "name": "Op", "val": 0}
  ],
  "gates": [
    {"type": "NOT", "pos": [170, 120], "orient": "s", "in": 9, "out": 10},
    {"type": "AND", "pos": [230, 170], "in": [11, 12], "out": 13},
    {"type": "AND", "pos": [230, 230], "in": [14, 15], "out": 16}
  ],
  "out": [
    {"pos": [300, 170], "id": 3, "name": "A filtré"},
    {"pos": [300, 230], "id": 4, "name": "B filtré"}
  ],
  "wires": [
    [2, 9],
    [13, 3],
    [16, 4],
    [0, 12],
    [1, 15],
    [10, 11],
    [2, 14, {"waypoints": [[130, 220]]}]
  ]
}
</script></logic-editor></div><p>Essayez ce circuit. Quand <span class="math notranslate nohighlight">\(Op=0\)</span>, <span class="math notranslate nohighlight">\(B\)</span> filtré sera toujours 0 mais <span class="math notranslate nohighlight">\(A\)</span> passera, et inversement.</p>
<p>Pour recombiner ces sorties filtrées, il ne nous reste plus qu’à les connecter par une porte <strong>OU</strong> :</p>
<div class="logic-container" style="height: 290px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 180], "id": 0, "name": "A", "val": 0},
    {"pos": [50, 240], "id": 1, "name": "B", "val": 0},
    {"pos": [130, 50], "orient": "s", "id": 2, "name": "Op", "val": 0}
  ],
  "gates": [
    {"type": "NOT", "pos": [170, 120], "orient": "s", "in": 9, "out": 10},
    {"type": "AND", "pos": [230, 170], "in": [11, 12], "out": 13},
    {"type": "AND", "pos": [230, 230], "in": [14, 15], "out": 16},
    {"type": "OR", "pos": [360, 200], "in": [5, 6], "out": 7}
  ],
  "out": [{"pos": [430, 200], "id": 8, "name": "Z"}],
  "wires": [
    [2, 9],
    [0, 12],
    [1, 15],
    [10, 11],
    [2, 14, {"waypoints": [[130, 220]]}],
    [13, 5],
    [16, 6],
    [7, 8]
  ]
}
</script></logic-editor></div><p>Essayez ce circuit pour confirmer qu’il agit comme un sélecteur : lorsque <span class="math notranslate nohighlight">\(Op=0\)</span>, on aura sur la sortie <span class="math notranslate nohighlight">\(Z=A\)</span>, et lorsque <span class="math notranslate nohighlight">\(Op=1\)</span>, on aura <span class="math notranslate nohighlight">\(Z=B\)</span>.</p>
<p>Ceci nous permet de compléter le circuit lacunaire de début de chapitre pour sélectionner avec le même mécanisme soit le <strong>OU</strong> soit le <strong>ET</strong> de nos deux entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span>. On ajoute notre sélecteur en connectant à l’entrée <span class="math notranslate nohighlight">\(A\)</span> le signal représentant <span class="math notranslate nohighlight">\(X\)</span> <strong>OU</strong> <span class="math notranslate nohighlight">\(Y\)</span>, et à l’entrée <span class="math notranslate nohighlight">\(B\)</span> le signal représentant <span class="math notranslate nohighlight">\(X\)</span> <strong>ET</strong> <span class="math notranslate nohighlight">\(Y\)</span> :</p>
<div class="logic-container" style="height: 300px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [230, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 170], "id": 19, "name": "X", "val": 0},
    {"pos": [50, 250], "id": 20, "name": "Y", "val": 0}
  ],
  "out": [{"pos": [530, 200], "id": 8, "name": "Z"}],
  "gates": [
    {"type": "NOT", "pos": [270, 120], "orient": "s", "in": 9, "out": 10},
    {"type": "AND", "pos": [330, 170], "in": [11, 12], "out": 13},
    {"type": "AND", "pos": [330, 230], "in": [14, 15], "out": 16},
    {"type": "OR", "pos": [460, 200], "in": [5, 6], "out": 7},
    {"type": "OR", "pos": [170, 180], "in": [0, 1], "out": 3},
    {"type": "AND", "pos": [170, 240], "in": [4, 17], "out": 18}
  ],
  "wires": [
    [2, 9],
    [10, 11],
    [2, 14, {"waypoints": [[230, 220]]}],
    [13, 5],
    [16, 6],
    [7, 8],
    [3, 12],
    [18, 15],
    [19, 0],
    [19, 4],
    [20, 17],
    [20, 1]
  ]
}
</script></logic-editor></div><div class="admonition-exercice-1-test-du-selecteur-ou-et admonition">
<p class="admonition-title">Exercice 1 : test du sélecteur <strong>OU</strong>/<strong>ET</strong></p>
<p>Testez le circuit ci-dessus. Établissez la table de vérité de <span class="math notranslate nohighlight">\(Z\)</span> en fonction de <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(Y\)</span> et <span class="math notranslate nohighlight">\(Op\)</span>. À l’aide de la table de vérité, montrez que, lorsque <span class="math notranslate nohighlight">\(Op=0\)</span>, <span class="math notranslate nohighlight">\(Z\)</span> représente bien <span class="math notranslate nohighlight">\(X\)</span> <strong>OU</strong> <span class="math notranslate nohighlight">\(Y\)</span>, et que, lorsque <span class="math notranslate nohighlight">\(Op=1\)</span>, <span class="math notranslate nohighlight">\(Z\)</span> représente bien <span class="math notranslate nohighlight">\(X\)</span> <strong>ET</strong> <span class="math notranslate nohighlight">\(Y\)</span>.</p>
</div>
<p>Nous avons ici construit un circuit qui, grâce à un bit de contrôle <span class="math notranslate nohighlight">\(Op\)</span>, sélectionne une opération ou une autre à appliquer à ses deux bits d’entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<div class="admonition-exercice-2-construction-d-un-selecteur admonition">
<p class="admonition-title">Exercice 2 : construction d’un sélecteur</p>
<p>En réutilisant les principes appliqués ci-dessus, construisez un circuit à deux bits d’entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span> et un bit de contrôle <span class="math notranslate nohighlight">\(Op\)</span> qui donnera sur sa sortie <span class="math notranslate nohighlight">\(Z\)</span> :</p>
<ul class="simple">
<li><p>Le <strong>OU</strong> exclusif de <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span>, lorsque <span class="math notranslate nohighlight">\(Op=0\)</span> ;</p></li>
<li><p>L’inverse du bit <span class="math notranslate nohighlight">\(Y\)</span>, lorsque <span class="math notranslate nohighlight">\(Op=1\)</span>.</p></li>
</ul>
<div class="logic-container" style="height: 400px;"><logic-editor showonly="AND OR NOT XOR">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [230, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 170], "id": 19, "name": "X", "val": 0},
    {"pos": [50, 250], "id": 20, "name": "Y", "val": 0}
  ],
  "out": [{"pos": [530, 200], "id": 8, "name": "Z"}]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Voici un circuit qui réutilise le sélecteur de signal et qui fournit à ce sélecteur les deux nouvelles entrées décrites, à savoir, en haut, le <strong>OU</strong> exclusif de <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span> tel que fourni par une porte <strong>OU-X</strong>, et en bas, <span class="math notranslate nohighlight">\(Y\)</span> une fois inversé par une porte <strong>NON</strong> :</p>
<div class="logic-container" style="height: 300px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [230, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 170], "id": 19, "name": "X", "val": 0},
    {"pos": [50, 250], "id": 20, "name": "Y", "val": 0}
  ],
  "out": [{"pos": [530, 200], "id": 8, "name": "Z"}],
  "gates": [
    {"type": "NOT", "pos": [270, 120], "orient": "s", "in": 9, "out": 10},
    {"type": "AND", "pos": [330, 170], "in": [11, 12], "out": 13},
    {"type": "AND", "pos": [330, 230], "in": [14, 15], "out": 16},
    {"type": "OR", "pos": [460, 200], "in": [5, 6], "out": 7},
    {"type": "XOR", "pos": [170, 180], "in": [0, 1], "out": 3},
    {"type": "NOT", "pos": [170, 250], "in": 21, "out": 22}
  ],
  "wires": [
    [2, 9],
    [10, 11],
    [2, 14, {"waypoints": [[230, 220]]}],
    [13, 5],
    [16, 6],
    [7, 8],
    [3, 12],
    [19, 0],
    [20, 1],
    [20, 21],
    [22, 15]
  ]
}
</script></logic-editor></div></div>
</details></div>
<div class="admonition-exercice-3-inverseur-conditionnel admonition">
<p class="admonition-title">Exercice 3 : inverseur conditionnel</p>
<p>En réutilisant les principes appliqués ci-dessus, construisez un circuit à une entrée <span class="math notranslate nohighlight">\(X\)</span> avec un bit de contrôle <span class="math notranslate nohighlight">\(Op\)</span> qui donnera sur sa sortie <span class="math notranslate nohighlight">\(Z\)</span> :</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X\)</span> tel quel, lorsque <span class="math notranslate nohighlight">\(Op=0\)</span> ;</p></li>
<li><p><span class="math notranslate nohighlight">\(X\)</span> inversé, lorsque <span class="math notranslate nohighlight">\(Op=1\)</span>.</p></li>
</ul>
<p>Écrivez la table de vérité de ce circuit. Correspond-elle par hasard à une porte déjà connue? Serait-ce dès lors possible de simplifier votre circuit?</p>
<div class="logic-container" style="height: 400px;"><logic-editor showonly="AND OR NOT XOR">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [230, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 170], "id": 19, "name": "X", "val": 0},
    {"pos": [50, 250], "id": 20, "name": "Y", "val": 0}
  ],
  "out": [{"pos": [530, 200], "id": 8, "name": "Z"}]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Voici une proposition qui réutilise le sélecteur de signal et qui fournit à ce sélecteur <span class="math notranslate nohighlight">\(X\)</span> en haut et <span class="math notranslate nohighlight">\(X\)</span> inversé en bas :</p>
<div class="logic-container" style="height: 290px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [150, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 180], "id": 19, "name": "X", "val": 0}
  ],
  "out": [{"pos": [450, 200], "id": 8, "name": "Z"}],
  "gates": [
    {"type": "NOT", "pos": [190, 120], "orient": "s", "in": 9, "out": 10},
    {"type": "AND", "pos": [250, 170], "in": [11, 12], "out": 13},
    {"type": "AND", "pos": [250, 230], "in": [14, 15], "out": 16},
    {"type": "OR", "pos": [380, 200], "in": [5, 6], "out": 7},
    {"type": "NOT", "pos": [120, 240], "in": 23, "out": 24}
  ],
  "wires": [
    [2, 9],
    [10, 11],
    [2, 14, {"waypoints": [[150, 220]]}],
    [13, 5],
    [16, 6],
    [7, 8],
    [19, 12],
    [19, 23],
    [24, 15]
  ]
}
</script></logic-editor></div><p class="card-text">La table de vérité est identique à celle d’une porte <strong>OU-X</strong>. On peut donc simplement remplacer tout le circuit par cette unique porte :</p>
<div class="logic-container" style="height: 180px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [100, 50], "orient": "s", "id": 2, "name": "Op", "val": 0},
    {"pos": [50, 130], "id": 19, "name": "X", "val": 0}
  ],
  "out": [{"pos": [210, 120], "id": 8, "name": "Z"}],
  "gates": [{"type": "XOR", "pos": [140, 120], "in": [25, 26], "out": 27}],
  "wires": [[19, 26], [2, 25], [27, 8]]
}
</script></logic-editor></div></div>
</details></div>
</section>
<section id="une-alu-a-4-bits">
<h3>Une ALU à 4 bits<a class="headerlink" href="#une-alu-a-4-bits" title="Lien permanent vers ce titre">¶</a></h3>
<p>Une unité arithmétique et logique, ou ALU, est un circuit qui ressemble dans ses principes de base à ce que nous venons de faire. L’ALU réaliste plusieurs opérations et permet de sélectionner, via un ou plusieurs bits de contrôle, l’opération qui est réalisée. Les opérations proposées sont, comme le nom de l’ALU indique, des opérations arithmétiques (typiquement, l’addition et la soustraction) et des opérations logiques (par exemple, un <strong>ET</strong> et un <strong>OU</strong> logiques).</p>
<p>Nous présentons ici une ALU simple à 4 bits :</p>
<div class="logic-container" style="height: 240px;"><logic-editor mode="static">
<script type="application/json">
{
  "v": 1,
  "opts": {"showDisconnectedPins": true},
  "components": [
    {
      "type": "alu",
      "pos": [70, 120],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, {"id": 15, "force": 0}],
      "showOp": false
    }
  ]
}
</script></logic-editor></div><p>Cette ALU sait effectuer l’addition ou la soustraction de deux nombres entiers représentés sur 4 bits. Elle a ainsi 8 bits d’entrée pour les données et 4 bits de sorties, à gauche et à droite. En plus de l’addition et de la soustraction, elle sait aussi faire les opérations logiques <strong>ET</strong> et <strong>OU</strong> — en tout donc, quatre opérations. Pour sélectionner l’une des quatre opérations, on ne peut plus se contenter d’un seul bit de contrôle, mais nous allons en utiliser deux pour avoir quatre combinaisons possibles. Ce sont les deux entrées supérieures de l’ALU. La convention utilisée pour la sélection de l’opération est la suivante :</p>
<div class="table-wrapper"><table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p><span class="math notranslate nohighlight">\(Op\)</span></p></th>
<th class="text-align:center head"><p>Opération effectuée</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>00</p></td>
<td class="text-align:center"><p>Addition</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>01</p></td>
<td class="text-align:center"><p>Soustraction</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>10</p></td>
<td class="text-align:center"><p><strong>OU</strong></p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>11</p></td>
<td class="text-align:center"><p><strong>ET</strong></p></td>
</tr>
</tbody>
</table></div>
<div class="admonition-exercice-4-test-de-l-alu admonition">
<p class="admonition-title">Exercice 4 : test de l’ALU</p>
<p>Connectez cette ALU à 8 entrées et à 4 sorties de manière à lui faire effectuer l’opération <span class="math notranslate nohighlight">\(7 + 2 = 9\)</span>. Connectez les 4 bits des entrées et de la sortie à des afficheurs de demi-octet pour vérifier leur fonctionnement. Connectez ensuite une entrée pour le bit de contrôle qui permettra d’effectuer la soustraction avec les mêmes données d’entrée, donc <span class="math notranslate nohighlight">\(7 - 2 = 5\)</span>.</p>
<div class="logic-container" style="height: 400px;"><logic-editor showonly="in in.nibble out out.nibble">
<script type="application/json">
{
  "v": 1,
  "components": [
    {
      "type": "alu", "pos": [300, 200],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], "out": [10, 11, 12, 13, 14, 15]
    }
  ]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="logic-container" style="height: 400px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "components": [
    {
      "type": "alu",
      "pos": [300, 200],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, 15]
    }
  ],
  "in": [
    {"pos": [50, 70], "id": 16, "val": 1},
    {"pos": [50, 100], "id": 17, "val": 1},
    {"pos": [50, 130], "id": 18, "val": 1},
    {"pos": [50, 160], "id": 19, "val": 0},
    {"pos": [50, 250], "id": 24, "val": 0},
    {"pos": [50, 280], "id": 25, "val": 1},
    {"pos": [50, 310], "id": 26, "val": 0},
    {"pos": [50, 340], "id": 27, "val": 0},
    {"pos": [360, 60], "orient": "w", "id": 36, "name": "Add./Soustr.", "val": 0}
  ],
  "out": [
    {"type": "nibble", "pos": [220, 50], "id": [20, 21, 22, 23], "name": "A"},
    {"type": "nibble", "pos": [220, 350], "id": [28, 29, 30, 31], "name": "B"},
    {"type": "nibble", "pos": [400, 200], "id": [32, 33, 34, 35], "name": "S"}
  ],
  "wires": [
    [16, 20],
    [17, 21],
    [18, 22],
    [19, 23],
    [16, 0],
    [17, 1],
    [18, 2],
    [19, 3],
    [24, 4],
    [25, 5],
    [26, 6],
    [27, 7],
    [24, 28],
    [25, 29],
    [26, 30],
    [27, 31],
    [10, 32],
    [11, 33],
    [12, 34],
    [13, 35],
    [36, 8]
  ]
}
</script></logic-editor></div></div>
</details></div>
<p>L’ALU a deux sorties en plus, en bas du composant :</p>
<ul class="simple">
<li><p>la sortie <span class="math notranslate nohighlight">\(V\)</span> (pour <em>oVerflow</em>) vaut 1 lors d’un dépassement de capacité (si le résultat de l’opération arithmétique représenté sur la sortie n’est pas valable parce qu’il vaudrait davantage de bits pour le représenter ; par exemple, le résultat de <span class="math notranslate nohighlight">\(8 + 8 = 16\)</span> n’est pas représentable sur 4 bits, qui suffisent à représenter les valeurs entières jusqu’à 15 seulement) ;</p></li>
<li><p>la sortie <span class="math notranslate nohighlight">\(Z\)</span> (pour <em>Zero</em>) vaut 1 lorsque tous les bits de sortie valent 0.</p></li>
</ul>
<div class="admonition-exercice-5-une-alu-comme-comparateur admonition">
<p class="admonition-title">Exercice 5 : une ALU comme comparateur</p>
<p>En programmation, c’est fréquent de tester, par exemple dans une condition avec un <code class="docutils literal notranslate"><span class="pre">if</span></code>, si deux valeurs sont égales. Par exemple, ce fragment de code affichera « Ces valeurs sont égales! » uniquement si les deux nombres entiers donnés lors de l’exécution du code sont les mêmes:</p>
<div class="interactive_code"><iframe border="0" cellspacing="0" class="codeframe" data-code="QSA9IGludChpbnB1dCgiUXVlbCBlc3QgbGUgcHJlbWllciBub21icmU/ICIpKQpCID0gaW50KGlucHV0KCJRdWVsIGVzdCBsZSBzZWNvbmQgbm9tYnJlPyAiKSkKaWYgQSA9PSBCOgogICAgcHJpbnQoIkNlcyB2YWxldXJzIHNvbnQgw6lnYWxlcyEiKQ==" data-file="Y29kZS5weQ==" frameborder="0" scrolling="no" src="../codeplay/frame.html"></iframe></div><p>Ce qui nous intéresse spécialement, c’est la comparaison à la ligne 3. Cette comparaison peut être réalisée avec une ALU. Pour cet exercice, créez un circuit avec une ALU qui compare deux nombres de quatre bits et indique sur la sortie <span class="math notranslate nohighlight">\(Z\)</span> un 1 si les deux nombres sont égaux et un 0 s’ils sont différents.</p>
<div class="logic-container" style="height: 330px;"><logic-editor showonly="ALU in out NOT OR AND XOR">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 16, "val": 0},
    {"pos": [50, 60], "id": 17, "val": 0},
    {"pos": [50, 90], "id": 18, "val": 0},
    {"pos": [50, 120], "id": 19, "val": 0},
    {"pos": [50, 210], "id": 24, "val": 0},
    {"pos": [50, 240], "id": 25, "val": 0},
    {"pos": [50, 270], "id": 26, "val": 0},
    {"pos": [50, 300], "id": 27, "val": 0}
  ],
  "out": [{"pos": [410, 160], "id": 37, "name": "Z"}]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Indice<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Deux nombres <span class="math notranslate nohighlight">\(A\)</span> et <span class="math notranslate nohighlight">\(B\)</span> sont égaux si leur différence est nulle — donc si tous les bits de sortie de <span class="math notranslate nohighlight">\(A - B\)</span> valent 0.</p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé avec ALU — approche arithmétique<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">On connecte les 8 entrées, on règle l’opération de l’ALU sur soustraction et on utilise la sortie de l’ALU qui indique si tous les bits de sortie sont à zéro. En effet, cela ne se produit que lorsque la différence entre les deux nombres d’entrée est 0 — c’est-à-dire, s’ils sont égaux. On constate qu’on peut ignorer les 4 bits de sorties ici !</p>
<div class="logic-container" style="height: 330px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 16, "val": 0},
    {"pos": [50, 60], "id": 17, "val": 0},
    {"pos": [50, 90], "id": 18, "val": 0},
    {"pos": [50, 120], "id": 19, "val": 0},
    {"pos": [50, 210], "id": 24, "val": 0},
    {"pos": [50, 240], "id": 25, "val": 0},
    {"pos": [50, 270], "id": 26, "val": 0},
    {"pos": [50, 300], "id": 27, "val": 0},
    {"pos": [230, 30], "orient": "s", "id": 54, "val": 1}
  ],
  "out": [{"pos": [410, 160], "id": 37, "name": "Z"}],
  "components": [
    {
      "type": "alu",
      "pos": [220, 150],
      "in": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47],
      "out": [48, 49, 50, 51, 52, 53]
    }
  ],
  "wires": [
    [16, 38],
    [17, 39],
    [18, 40],
    [19, 41],
    [24, 42],
    [25, 43],
    [26, 44],
    [27, 45],
    [54, 46],
    [53, 37]
  ]
}
</script></logic-editor></div></div>
</details><p>Plus difficile : essayez de réaliser un circuit qui calcule la même valeur de sortie, mais sans utiliser d’ALU.</p>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Indice<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Une porte <strong>OU-X</strong> peut être vue comme un comparateur de deux bits : sa sortie vaudra 1 si et seulement si ses deux entrées sont différentes.</p>
</div>
</details><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé sans ALU — approche logique<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Cette solution utilise des portes <strong>OU-X</strong> comme comparateurs. On voit ici que 4 portes <strong>OU-X</strong> comparent deux à deux les 8 bits d’entrée. Leurs sorties sont ensuite combinées avec des portes <strong>OU</strong>, afin d’obtenir un signal qui vaudra 1 si au moins une différence est détectée, donc si les deux nombres d’entrées ne sont pas égaux. Il ne reste plus qu’à inverser ce signal pour obtenir la sortie demandée qui, selon la donnée, doit valoir 1 lorsque les nombres sont égaux.</p>
<div class="logic-container" style="height: 330px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 16, "val": 0},
    {"pos": [50, 60], "id": 17, "val": 0},
    {"pos": [50, 90], "id": 18, "val": 0},
    {"pos": [50, 120], "id": 19, "val": 0},
    {"pos": [50, 210], "id": 24, "val": 0},
    {"pos": [50, 240], "id": 25, "val": 0},
    {"pos": [50, 270], "id": 26, "val": 0},
    {"pos": [50, 300], "id": 27, "val": 0}
  ],
  "out": [{"pos": [530, 160], "id": 37, "name": "Z"}],
  "gates": [
    {"type": "XOR", "pos": [190, 270], "in": [55, 56], "out": 57},
    {"type": "OR", "pos": [290, 210], "in": [58, 59], "out": 60},
    {"type": "OR", "pos": [290, 110], "in": [61, 62], "out": 63},
    {"type": "OR", "pos": [390, 160], "in": [64, 65], "out": 66},
    {"type": "XOR", "pos": [190, 200], "in": [67, 68], "out": 69},
    {"type": "XOR", "pos": [190, 120], "in": [70, 71], "out": 72},
    {"type": "XOR", "pos": [190, 50], "in": [73, 74], "out": 75},
    {"type": "NOT", "pos": [460, 160], "in": 76, "out": 77}
  ],
  "wires": [
    [16, 73],
    [24, 74],
    [17, 70],
    [25, 71],
    [18, 67],
    [26, 68],
    [19, 55],
    [27, 56],
    [75, 61],
    [72, 62],
    [63, 64],
    [60, 65],
    [69, 58],
    [57, 59],
    [66, 76],
    [77, 37]
  ]
}
</script></logic-editor></div></div>
</details></div>
<p>En résumé, nous avons appris ici ce qu’est une unité arithmétique et logique et avons examiné de plus près comment construire un circuit qui est à même de « choisir » parmi plusieurs signaux d’entrées. L’ALU est spécialement intéressante, car c’est le premier composant que nous rencontrons qui incarne une des propriétés de base d’un ordinateur, à savoir d’être programmable, en faisant en sorte que l’opération effectuée ne soit pas préprogrammée mais dépende d’un signal externe.</p>
<div class="attention admonition">
<p class="admonition-title">Pour aller plus loin</p>
<p>Notre petite ALU peut aussi faire des calculs en utilisant une représentation signée des nombres entiers. Sur 4 bits, une représentation en complément à deux peut représenter les nombres de <span class="math notranslate nohighlight">\(-8\)</span> à <span class="math notranslate nohighlight">\(+7\)</span>. Il est possible d’utiliser les mêmes afficheurs de demi-octets en mode signé pour effectuer des opérations arithmétiques avec des valeurs négatives, par exemple, ici, <span class="math notranslate nohighlight">\(-2 - (-4) = 2\)</span> :</p>
<div class="logic-container" style="height: 400px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 70], "id": 16, "val": 0},
    {"pos": [50, 100], "id": 17, "val": 1},
    {"pos": [50, 130], "id": 18, "val": 1},
    {"pos": [50, 160], "id": 19, "val": 1},
    {"pos": [50, 250], "id": 24, "val": 0},
    {"pos": [50, 280], "id": 25, "val": 0},
    {"pos": [50, 310], "id": 26, "val": 1},
    {"pos": [50, 340], "id": 27, "val": 1},
    {"pos": [360, 60], "orient": "w", "id": 36, "name": "Add./Soustr.", "val": 1}
  ],
  "out": [
    {
      "type": "nibble",
      "pos": [220, 50],
      "id": [20, 21, 22, 23],
      "name": "A",
      "radix": -10
    },
    {
      "type": "nibble",
      "pos": [220, 350],
      "id": [28, 29, 30, 31],
      "name": "B",
      "radix": -10
    },
    {
      "type": "nibble",
      "pos": [400, 200],
      "id": [32, 33, 34, 35],
      "name": "S",
      "radix": -10
    }
  ],
  "components": [
    {
      "type": "alu",
      "pos": [300, 200],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, 15]
    }
  ],
  "wires": [
    [16, 20],
    [17, 21],
    [18, 22],
    [19, 23],
    [16, 0],
    [17, 1],
    [18, 2],
    [19, 3],
    [24, 4],
    [25, 5],
    [26, 6],
    [27, 7],
    [24, 28],
    [25, 29],
    [26, 30],
    [27, 31],
    [10, 32],
    [11, 33],
    [12, 34],
    [13, 35],
    [36, 8]
  ]
}
</script></logic-editor></div><p>Notez que grâce à la représentation en complément à deux, la circuiterie interne de l’ALU peut se permettre de complètement ignorer si ses entrées sont signées ou pas et livrera le bon résultat tant que la convention d’entrée et de sortie reste la même.</p>
</div>
</section>
</section>
<section id="memoire">
<h2>Mémoire<a class="headerlink" href="#memoire" title="Lien permanent vers ce titre">¶</a></h2>
<p>Les <span class="target" id="gl-transistor-0"></span><span class="glossary-ref" data-definition="PHA+TGXCoHRyYW5zaXN0b3LCoGVzdCB1bsKgY29tcG9zYW50wqBxdWkgZXN0IHV0aWxpc8OpIGRhbnMgbGEgcGx1cGFydCBkZXPCoGNpcmN1aXRzIMOpbGVjdHJvbmlxdWVzwqAoY2lyY3VpdCBsb2dpcXVlLMKgYW1wbGlmaWNhdGV1ciwgc3RhYmlsaXNhdGV1ciBkZcKgdGVuc2lvbizCoG1vZHVsYXRpb27CoGRlwqBzaWduYWwswqBldGMuKS48L3A+Cg==" data-entry-name="VHJhbnNpc3Rvcg==" data-glossary-uri="../glossaire.html#gl-def-transistor-1" data-number="1">transistors</span>, les <span class="target" id="gl-portelogique-0"></span><span class="glossary-ref" data-definition="PHA+TGVzIHBvcnRlcyBsb2dpcXVlcyBzb250IGRlcyB1bml0w6lzIG1pY3Jvw6lsZWN0cm9uaXF1ZXMsIG91IHN5bWJvbGlxdWVzLCBwZXJtZXR0YW50IGRlIHJlcHJvZHVpcmUgbGEgbG9naXF1ZSBib29sw6llbm5lIHZpYSBkZXMgdGVuc2lvbnMgw6lsZWN0cmlxdWVzLjwvcD4K" data-entry-name="UG9ydGVzIGxvZ2lxdWVz" data-glossary-uri="../glossaire.html#gl-def-portelogique-1" data-number="1">portes logiques</span> et leur représentation en <span class="target" id="gl-tableverite-0"></span><span class="glossary-ref" data-definition="PHA+RW4gbG9naXF1ZSwgdW5lIHRhYmxlIGRlIHbDqXJpdMOpIGVzdCB1bmUgZmHDp29uIGRlIHJlcHLDqXNlbnRlciBsZXMg4oCcZW50csOpZXPigJ0gZXQgbGVzIOKAnHNvcnRpZXPigJ0gZOKAmXVuIHN5c3TDqG1lIGxvZ2lxdWUgZGUgZmHDp29uIGdyYXBoaXF1ZS48L3A+Cg==" data-entry-name="VGFibGUgZGUgdsOpcml0w6k=" data-glossary-uri="../glossaire.html#gl-def-tableverite-1" data-number="1">tables de vérités</span>, permettent de manipuler des 0 et des 1 au niveau physique… Tant qu’un courant électrique se déplace dans les <span class="target" id="gl-circuit-0"></span><span class="glossary-ref" data-definition="PHA+VW4gY2lyY3VpdCBsb2dpcXVlIGVzdCB1bmUgY29tYmluYWlzb24gZGUgcG9ydGVzIGxvZ2lxdWVzLjwvcD4K" data-entry-name="Q2lyY3VpdCBsb2dpcXVl" data-glossary-uri="../glossaire.html#gl-def-circuit-1" data-number="1">circuits</span>, on est capable de le transformer, de le laisser passer ou de l’arrêter, dans le but d’exprimer des portes « ouvertes » ou des portes « fermées » et donc des nombres binaires. L’ALU va une étape plus loin et permet de choisir une opération à effectuer en fonction de bits de contrôle supplémentaire, et livre le résultat de l’opération arithmétique ou logique choisie.</p>
<p>Mais comment faire pour <span class="target" id="gl-stockage-0"></span><span class="glossary-ref" data-definition="PHA+RW4gaW5mb3JtYXRpcXVlLCBvbiBlbnRlbmQgcGFyIHN0b2NrYWdlIHVuIHByb2Nlc3N1cyBncsOiY2UgYXVxdWVsIHVuIGNlcnRhaW4gbm9tYnJlIGRlIGJpdHMgZOKAmWluZm9ybWF0aW9uIHBldXZlbnQgw6p0cmUgY29uc2VydsOpcyBkYW5zIGxlIHRlbXBzLiBJbCBleGlzdGUgZGVzIHN0b2NrYWdlcyBkZSBjb3VydGUgZXQgZGUgbG9uZ3VlIGR1csOpZSwgYWluc2kgcXXigJl1bmUgbXVsdGlwbGljaXTDqSBkZSB0ZWNobmlxdWVzIHBlcm1ldHRhbnQgZGUgc3RvY2tlciBkZSBs4oCZaW5mb3JtYXRpb24gc291cyBmb3JtZSBkZSBiaXRzLjwvcD4K" data-entry-name="U3RvY2thZ2U=" data-glossary-uri="../glossaire.html#gl-def-stockage-1" data-number="1">stocker</span> cette information ? Comment faire pour que l’on se rappelle le résultat d’une addition effectuée par une ALU afin de pouvoir réutiliser cette valeur plus tard ? C’est là que nous avons besoin de <em>mémoire</em>.</p>
<p>Dans les ordinateurs, il y a en fait plusieurs types de <span class="target" id="gl-stockage-1"></span><span class="glossary-ref" data-definition="PHA+RW4gaW5mb3JtYXRpcXVlLCBvbiBlbnRlbmQgcGFyIHN0b2NrYWdlIHVuIHByb2Nlc3N1cyBncsOiY2UgYXVxdWVsIHVuIGNlcnRhaW4gbm9tYnJlIGRlIGJpdHMgZOKAmWluZm9ybWF0aW9uIHBldXZlbnQgw6p0cmUgY29uc2VydsOpcyBkYW5zIGxlIHRlbXBzLiBJbCBleGlzdGUgZGVzIHN0b2NrYWdlcyBkZSBjb3VydGUgZXQgZGUgbG9uZ3VlIGR1csOpZSwgYWluc2kgcXXigJl1bmUgbXVsdGlwbGljaXTDqSBkZSB0ZWNobmlxdWVzIHBlcm1ldHRhbnQgZGUgc3RvY2tlciBkZSBs4oCZaW5mb3JtYXRpb24gc291cyBmb3JtZSBkZSBiaXRzLjwvcD4K" data-entry-name="U3RvY2thZ2U=" data-glossary-uri="../glossaire.html#gl-def-stockage-1" data-number="1">mémoires</span>, qu’on peut classer en deux grandes catégories. La <span class="target" id="gl-memvolatile-0"></span><span class="glossary-ref" data-definition="PHA+TGEgbcOpbW9pcmUgdm9sYXRpbGUgZOKAmXVuIG9yZGluYXRldXIgZXN0IHVuZSBtw6ltb2lyZSBkb250IGxhIGR1csOpZSBkZSB2aWUgZXN0IGxpbWl0w6llIMOgIGxhIG1pc2Ugc291cyB0ZW5zaW9uIGRlcyBjaXJjdWl0cy48L3A+Cg==" data-entry-name="TcOpbW9pcmUgdm9sYXRpbGU=" data-glossary-uri="../glossaire.html#gl-def-memvolatile-1" data-number="1">mémoire volatile</span>, et la mémoire non volatile. La mémoire volatile s’efface quand la machine et éteinte. C’est le cas de la RAM (<em>random-access memory</em>), par exemple. La <span class="target" id="gl-memnonvolatile-0"></span><span class="glossary-ref" data-definition="PHA+TGEgbcOpbW9pcmUgbm9uIHZvbGF0aWxlIGTigJl1biBvcmRpbmF0ZXVyIGVzdCB1bmUgbcOpbW9pcmUgZG9udCBsYSBkdXLDqWUgZGUgdmllIG91dHJlcGFzc2UgbGEgbWlzZSBob3JzIHRlbnNpb24gZGVzIGNpcmN1aXRzLjwvcD4K" data-entry-name="TcOpbW9pcmUgbm9uIHZvbGF0aWxl" data-glossary-uri="../glossaire.html#gl-def-memnonvolatile-1" data-number="1">mémoire non volatile</span>, elle, persiste. C’est le cas d’un disque dur ou d’un SSD (<em>solid-state drive</em>). Si un smartphone s’éteint inopinément alors qu’on est en train de retoucher une photo sans avoir validé les modifications, ces retouches disparaissent. Elles étaient stockées sur la mémoire volatile. Par contre, au moment où ces retouches sont sauvegardées, elles s’inscrivent dans la mémoire non volatile.</p>
<p>On peut se demander pourquoi on n’utiliserait pas que de la mémoire non volatile, vu les « risques » posés par la mémoire volatile. La réponse est que la mémoire non volatile va probablement être entre 100 et 100 000 fois moins rapide que la mémoire volatile. On privilégie donc la mémoire volatile comme mémoire de travail rapide d’un ordinateur.</p>
<p>Dans les sections qui suivent, on propose de s’intéresser au cas le plus simple: la construction d’une cellule de mémoire volatile qui sera à même de stocker un bit. Par la suite, nous discuterons de la manière dont ce genre de mémoire est utilisée au cœur des microprocesseurs.</p>
<section id="le-verrou-sr">
<h3>Le verrou SR<a class="headerlink" href="#le-verrou-sr" title="Lien permanent vers ce titre">¶</a></h3>
<p>L’idée principale derrière la conception d’un circuit logique qui est capable de stocker un signal est que l’on va utiliser la ou les sorties du circuit en les reconnectant à certaines de ses entrées. Essayons par exemple ce circuit simple avec une seule porte <strong>OU</strong> :</p>
<div class="logic-container" style="height: 100px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [{"pos": [50, 30], "id": 4, "name": "X", "val": 0}],
  "gates": [{"type": "OR", "pos": [140, 40], "in": [5, 6], "out": 7}],
  "out": [{"pos": [240, 40], "id": 0, "name": "Z"}],
  "wires": [[4, 5], [7, 6, {"waypoints": [[170, 80, "w"], [110, 80, "w"]]}], [7, 0]]
}
</script></logic-editor></div><p>Au début, les deux entrées de la porte valent 0, comme sa sortie. Si l’on essaie de faire passer l’entrée <span class="math notranslate nohighlight">\(X\)</span> à 1, on voit que la sortie <span class="math notranslate nohighlight">\(Z\)</span> passera à 1 elle aussi, comme il s’agit d’une porte <strong>OU</strong>. Mais comme <span class="math notranslate nohighlight">\(Z\)</span> est aussi relié à l’autre entrée de la porte, on a maintenant un circuit dont on ne peut plus modifier la sortie : même si <span class="math notranslate nohighlight">\(X\)</span> passe de nouveau à 0, l’autre entrée reste à 1 et suffit donc pour que <span class="math notranslate nohighlight">\(Z\)</span> vale maintenant 1 indéfiniment. On est obligé de remettre le circuit complètement à zéro (l’équivalent de débrancher la prise de courant et de la rebrancher) pour obtenir à nouveau un 0 sur la sortie <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p>Assurément, ce circuit n’est pas très intéressant : il se bloque dans un état sans retour possible. Serait-ce possible de construire un circuit un peu plus élaboré qui permettrait de choisir la valeur de sa sortie et de la conserver ? Ces circuits existent en effet et sont à la base du stockage de l’information dans les microprocesseurs. On appelle ces circuits des <span class="target" id="gl-verrou-0"></span><span class="glossary-ref" data-definition="PHA+QXJjaGlvcmRpPC9wPgo=" data-entry-name="VmVycm91" data-glossary-uri="../glossaire.html#gl-def-verrou-1" data-number="1">verrous</span>, vu qu’ils « verrouillent » une valeur donnée.</p>
<p>Examinons le circuit ci-dessous : c’est le verrou dit « SR », pour <em>set/reset</em>, en anglais.</p>
<div class="logic-container" style="height: 160px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 8, "name": "R", "val": 0},
    {"pos": [50, 130], "id": 9, "name": "S", "val": 0}
  ],
  "out": [
    {"pos": [290, 40], "id": 10, "name": "Q"},
    {"pos": [290, 120], "id": 11, "name": "Q'"}
  ],
  "gates": [
    {"type": "OR", "pos": [130, 40], "in": [0, 1], "out": 2},
    {"type": "OR", "pos": [130, 120], "in": [4, 5], "out": 6},
    {"type": "NOT", "pos": [200, 120], "in": 3, "out": 7},
    {"type": "NOT", "pos": [200, 40], "in": 12, "out": 13}
  ],
  "wires": [
    [8, 0],
    [9, 5],
    [6, 3],
    [7, 11],
    [2, 12],
    [13, 10],
    [7, 1, {"waypoints": [[80, 50]]}],
    [13, 4, {"waypoints": [[80, 110]]}]
  ]
}
</script></logic-editor></div><p>Ce circuit stocke un bit de donnée un 0 ou un 1, qu’on va pouvoir lire via la sortie <span class="math notranslate nohighlight">\(Q\)</span> et modifier avec les deux entrées <span class="math notranslate nohighlight">\(R\)</span> et <span class="math notranslate nohighlight">\(S\)</span>. (La seconde sortie <span class="math notranslate nohighlight">\(\bar{Q}\)</span> est ici toujours l’inverse de <span class="math notranslate nohighlight">\(Q\)</span>.)</p>
<p>Dans l’état normal de ce verrou, la sortie <span class="math notranslate nohighlight">\(Q\)</span> vaut soit 1, soit 0, et les deux entrées <span class="math notranslate nohighlight">\(S\)</span> et <span class="math notranslate nohighlight">\(R\)</span> restent à 0. Testez le circuit ci-dessus et observez l’effet de <span class="math notranslate nohighlight">\(R\)</span> et <span class="math notranslate nohighlight">\(S\)</span>. <span class="math notranslate nohighlight">\(S\)</span>, pour <em>set</em>, sert à changer l’état du verrou pour lui faire dorénavant stocker un 1. « Allumer » <span class="math notranslate nohighlight">\(S\)</span> cause ainsi <span class="math notranslate nohighlight">\(Q\)</span> à passer à 1. Ce qu’il y a d’intéressant, c’est qu’une fois que <span class="math notranslate nohighlight">\(Q\)</span> est passé à 1, on peut sans autre « éteindre » le signal <span class="math notranslate nohighlight">\(S\)</span> et le faire repasser à 0, et la sortie <span class="math notranslate nohighlight">\(Q\)</span>, elle, reste à 1 — alors que les deux entrées du circuit <span class="math notranslate nohighlight">\(S\)</span> et <span class="math notranslate nohighlight">\(R\)</span> sont maintenant à nouveau les mêmes qu’avant, lorsque la sortie <span class="math notranslate nohighlight">\(Q\)</span> valait 0.</p>
<p>De manière similaire, l’entrée <span class="math notranslate nohighlight">\(R\)</span>, pour <em>reset</em>, sert à faire passer la valeur stockée par le du verrou à 0, et cet état reste 0 même lorsque <span class="math notranslate nohighlight">\(R\)</span> est de nouveau « éteint ».</p>
<p>On essaie en général d’éviter d’avoir un 1 sur <span class="math notranslate nohighlight">\(R\)</span> et sur <span class="math notranslate nohighlight">\(S\)</span> en même temps, cela place le verrou dans un état où <span class="math notranslate nohighlight">\(\bar{Q}\)</span> n’est plus l’inverse de <span class="math notranslate nohighlight">\(Q\)</span>. Pour cette raison, nous allons plutôt créer le circuit comme suit — les connexions sont exactement les mêmes, mais les entrées <span class="math notranslate nohighlight">\(S\)</span> et <span class="math notranslate nohighlight">\(R\)</span> ne restent pas à 1 lorsqu’on clique dessus, elles retombent à 0 dès que le clic se termine.</p>
<div class="logic-container" style="height: 160px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 8, "name": "R", "val": 0, "isPushButton": true},
    {"pos": [50, 130], "id": 9, "name": "S", "val": 0, "isPushButton": true}
  ],
  "out": [
    {"pos": [290, 40], "id": 10, "name": "Q"},
    {"pos": [290, 120], "id": 11, "name": "Q'"}
  ],
  "gates": [
    {"type": "OR", "pos": [130, 40], "in": [0, 1], "out": 2},
    {"type": "OR", "pos": [130, 120], "in": [4, 5], "out": 6},
    {"type": "NOT", "pos": [200, 120], "in": 3, "out": 7},
    {"type": "NOT", "pos": [200, 40], "in": 12, "out": 13}
  ],
  "wires": [
    [8, 0],
    [9, 5],
    [6, 3],
    [7, 11],
    [2, 12],
    [13, 10],
    [7, 1, {"waypoints": [[80, 50]]}],
    [13, 4, {"waypoints": [[80, 110]]}]
  ]
}
</script></logic-editor></div><p>Ces verrous sont communs, et pour le reste du chapitre, on simplifiera la notation pour les représenter ainsi, sans changement de fonctionnalité, mais en faisant abstraction des détails internes :</p>
<div class="logic-container" style="height: 100px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [50, 30], "id": 10, "name": "R", "val": 0, "isPushButton": true},
    {"pos": [50, 70], "id": 11, "name": "S", "val": 0, "isPushButton": true}
  ],
  "out": [
    {"pos": [210, 30], "id": 12, "name": "Q"},
    {"pos": [210, 70], "id": 13, "name": "Q'"}
  ],
  "components": [
    {"type": "latch-sr", "pos": [130, 50], "in": [6, 7], "out": [8, 9], "state": 0}
  ],
  "wires": [[10, 7], [11, 6], [8, 12], [9, 13]]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Pour aller plus loin<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Voici une vidéo qui illustre ce principe de verrou SR.</p>
<div class="video"><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="315" mozallowfullscreen="" src="https://www.youtube-nocookie.com/embed/KM0DdEaY5sY?start=298" webkitallowfullscreen="" width="560">"</iframe></div></div>
</details></section>
<section id="la-bascule-d">
<h3>La bascule D<a class="headerlink" href="#la-bascule-d" title="Lien permanent vers ce titre">¶</a></h3>
<p>Un souci avec le verrou SR est qu’on a rarement un signal d’entrée qui soit facilement exploitable pour être « converti » en cette logique <em>set/reset</em>. La plupart du temps, on a simplement un signal donné, disons <span class="math notranslate nohighlight">\(D\)</span>, pour « donnée » (ou <em>data</em> en anglais), et c’est ce signal-ci qu’on aimerait stocker. Avec ce système, il serait impossible de connecter <span class="math notranslate nohighlight">\(D\)</span> à ce verrou ; on ne peut le brancher directement ni à l’entrée <span class="math notranslate nohighlight">\(S\)</span>, ni à l’entrée <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p>On va utiliser pour cela un circuit similaire, mais qui fonctionne un peu différemment, qui s’appelle une <strong>bascule D</strong><a class="footnote-reference brackets" href="#flipflop" id="id1">1</a> :</p>
<div class="logic-container" style="height: 120px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [90, 40], "id": 0, "name": "D", "val": 0},
    {"pos": [90, 80], "id": 1, "name": "Horloge", "val": 0, "isPushButton": true}
  ],
  "out": [
    {"pos": [250, 40], "id": 9, "name": "Q"},
    {"pos": [250, 80], "id": 10, "name": "Q'"}
  ],
  "components": [
    {
      "type": "flipflop-d",
      "pos": [170, 60],
      "in": [3, 4, 5, 2],
      "out": [6, 7],
      "state": 0
    }
  ],
  "wires": [[0, 2], [1, 3], [6, 9], [7, 10]]
}
</script></logic-editor></div><p>Cette bascule va stocker son entrée <span class="math notranslate nohighlight">\(D\)</span> et la propager sur sa sortie <span class="math notranslate nohighlight">\(Q\)</span> uniquement lorsque l’entrée spéciale <span class="math notranslate nohighlight">\(Horloge\)</span> passe de 0 à 1. Le reste du temps, <span class="math notranslate nohighlight">\(Q\)</span> et <span class="math notranslate nohighlight">\(\overline{Q}\)</span> garderont leur valeur précédente. Notez que cette bascule a aussi deux entrées <span class="math notranslate nohighlight">\(S\)</span> et <span class="math notranslate nohighlight">\(R\)</span>, qui servent à forcer l’état interne à valoir 1 ou 0, respectivement, indépendamment du signal <span class="math notranslate nohighlight">\(D\)</span> et de l’horloge.</p>
<p>Testez cette bascule. Réglez l’entrée de données <span class="math notranslate nohighlight">\(D\)</span> à 1 ou 0 et observez comme la bascule ne réagit pas : sa sortie <span class="math notranslate nohighlight">\(Q\)</span> reste telle quelle. Donnez ensuite une impulsion en cliquant sur l’entrée <span class="math notranslate nohighlight">\(Horloge\)</span> et voyez comme la valeur de <span class="math notranslate nohighlight">\(D\)</span> est maintenant stockée sur la bascule.</p>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Pour aller plus loin<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Pour aller plus loin, une vidéo de résumé qui parle aussi des bascules et des registres :</p>
<div class="video"><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="" frameborder="0" height="315" mozallowfullscreen="" src="https://www.youtube-nocookie.com/embed/I0-izyq6q5s" webkitallowfullscreen="" width="560">"</iframe></div></div>
</details><div class="admonition-exercice-6-stocker-deux-bits admonition">
<p class="admonition-title">Exercice 6 : stocker deux bits</p>
<p>Créez un circuit qui calcule, d’une part, le <strong>OU</strong> de deux entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span>, et, d’autre part, le <strong>ET</strong> de ces deux mêmes entrées. À l’aide de bascules D, complétez le circuit de manière à ce qu’il stocke ces deux valeurs calculées lors d’un coup d’horloge et les sorte sur les sorties <span class="math notranslate nohighlight">\(P\)</span> et <span class="math notranslate nohighlight">\(Q\)</span>, respectivement. Faites finalement en sorte que le signal <span class="math notranslate nohighlight">\(Reset\)</span>, si activé, réinitialise les bascules à 0. Vérifiez qu’une fois les valeurs stockées par les bascules, des changements sur les entrées <span class="math notranslate nohighlight">\(X\)</span> et <span class="math notranslate nohighlight">\(Y\)</span> n’aient pas d’effet direct sur <span class="math notranslate nohighlight">\(P\)</span> et <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<div class="logic-container" style="height: 400px;"><logic-editor showonly="AND OR NOT XOR Flipflop-D">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [100, 50], "id": 24, "name": "X", "val": 1},
    {"pos": [100, 130], "id": 25, "name": "Y", "val": 1},
    {"pos": [100, 200], "id": 26, "name": "Horloge", "val": 0, "isPushButton": true},
    {"pos": [100, 270], "id": 29, "name": "Reset", "val": 0, "isPushButton": true}
  ],
  "out": [
    {"pos": [500, 50], "id": 27, "name": "P"},
    {"pos": [500, 160], "id": 28, "name": "Q"}
  ]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="logic-container" style="height: 320px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [100, 50], "id": 24, "name": "X", "val": 1},
    {"pos": [100, 130], "id": 25, "name": "Y", "val": 1},
    {"pos": [100, 200], "id": 26, "name": "Horloge", "val": 0, "isPushButton": true},
    {"pos": [100, 270], "id": 29, "name": "Reset", "val": 0, "isPushButton": true}
  ],
  "out": [
    {"pos": [500, 50], "id": 27, "name": "P"},
    {"pos": [500, 160], "id": 28, "name": "Q"}
  ],
  "gates": [
    {"type": "OR", "pos": [210, 60], "in": [0, 1], "out": 2},
    {"type": "AND", "pos": [210, 120], "in": [3, 4], "out": 5}
  ],
  "components": [
    {
      "type": "flipflop-d",
      "pos": [390, 70],
      "in": [7, 8, 9, 6],
      "out": [10, 11],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 180],
      "in": [13, 14, 15, 12],
      "out": [16, 17],
      "state": 0
    }
  ],
  "wires": [
    [24, 0],
    [25, 1],
    [24, 3],
    [25, 4],
    [10, 27],
    [16, 28],
    [2, 6],
    [5, 12],
    [26, 7],
    [26, 13],
    [29, 15, {"waypoints": [[340, 240]]}],
    [29, 9, {"waypoints": [[340, 130]]}]
  ]
}
</script></logic-editor></div></div>
</details></div>
<div class="admonition-exercice-7-signal-alternatif admonition">
<p class="admonition-title">Exercice 7 : signal alternatif</p>
<p>À l’aide d’une bascule, créez un circuit avec une sortie <span class="math notranslate nohighlight">\(Q\)</span> qui s’inverse à chaque coup d’horloge.</p>
<div class="logic-container" style="height: 300px;"><logic-editor showonly="AND OR NOT XOR Flipflop-D">
<script type="application/json">
{
  "v": 1,
  "in": [
    {"pos": [100, 90], "id": 6, "name": "Horloge", "val": 0, "isPushButton": true}
  ],
  "out": [{"pos": [380, 90], "id": 7, "name": "Q"}]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<div class="logic-container" style="height: 190px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "components": [
    {
      "type": "flipflop-d",
      "pos": [230, 100],
      "in": [1, 2, 3, 0],
      "out": [4, 5],
      "state": 0
    }
  ],
  "in": [
    {"pos": [100, 90], "id": 6, "name": "Horloge", "val": 0, "isPushButton": true}
  ],
  "out": [{"pos": [380, 90], "id": 7, "name": "Q"}],
  "wires": [
    [4, 7],
    [6, 1],
    [5, 0, {"waypoints": [[290, 120, "n"], [290, 40, "n"], [190, 40, "w"]]}]
  ]
}
</script></logic-editor></div></div>
</details></div>
<div class="admonition-exercice-8-jeu-de-frequences admonition">
<p class="admonition-title">Exercice 8 : jeu de fréquences</p>
<p>Observez le circuit ci-dessous. L’horloge principale <span class="math notranslate nohighlight">\(A\)</span> fonctionne ici toute seule et produit un coup d’horloge par seconde (elle a donc une fréquence d’un hertz — 1 Hz). Que pouvez-vous dire des signaux <span class="math notranslate nohighlight">\(B\)</span> et <span class="math notranslate nohighlight">\(C\)</span> par rapport au signal <span class="math notranslate nohighlight">\(A\)</span> ? Comment expliquer cela avec ce que vous savez des bascules ? (Pour simplifier, le délai de propagation est ici presque nul.)</p>
<p>Vous pouvez mettre l’animation en pause et exécuter chaque transition pas à pas pour mieux comprendre ce qui se passe.</p>
<div class="logic-container" style="height: 280px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "opts": {"propagationDelay": 0},
  "in": [{"type": "clock", "pos": [40, 30], "id": 30, "period": 1000}],
  "out": [
    {"pos": [380, 30], "id": 7, "name": "A"},
    {"pos": [380, 80], "id": 10, "name": "B"},
    {"pos": [380, 130], "id": 11, "name": "C"}
  ],
  "components": [
    {
      "type": "flipflop-d",
      "pos": [180, 100],
      "in": [13, 14, 15, 12],
      "out": [16, 17],
      "state": 1
    },
    {
      "type": "flipflop-d",
      "pos": [180, 230],
      "in": [25, 26, 27, 24],
      "out": [28, 29],
      "state": 1
    }
  ],
  "wires": [
    [16, 25, {"waypoints": [[250, 120, "s"], [120, 180, "s"]]}],
    [16, 10],
    [28, 11],
    [17, 12, {"waypoints": [[230, 120], [230, 50], [140, 50]]}],
    [29, 24, {"waypoints": [[230, 250], [230, 180], [140, 180]]}],
    [30, 13],
    [30, 7]
  ]
}
</script></logic-editor></div><details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Corrigé<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Le signal <span class="math notranslate nohighlight">\(B\)</span> a une fréquence deux fois plus petite que le signal <span class="math notranslate nohighlight">\(A\)</span>, et le signal <span class="math notranslate nohighlight">\(C\)</span>, de façon similaire, a une fréquence deux fois plus petite que le signal <span class="math notranslate nohighlight">\(B\)</span>. Ainsi, <span class="math notranslate nohighlight">\(B\)</span> « bat » à 0.5 Hz et <span class="math notranslate nohighlight">\(C\)</span> à 0.25 Hz.</p>
<p class="card-text">TODO ajouter explication</p>
<p class="card-text">Si ce petit circuit fonctionne à 1 Hz, les appareils que nous utilisons aujourd’hui ont des horloges qui fonctionnent à plusieurs gigahertz (GHz), c’est-à-dire plusieurs milliards de fois plus vite. On attend ainsi moins d’une nanoseconde entre deux coups d’horloge.</p>
</div>
</details></div>
</section>
<section id="addition-en-plusieurs-etapes">
<h3>Addition en plusieurs étapes<a class="headerlink" href="#addition-en-plusieurs-etapes" title="Lien permanent vers ce titre">¶</a></h3>
<p>Dans cet exemple final, nous allons construire un circuit capable d’effectuer l’addition de plusieurs nombres ; par exemple, d’évaluer la somme <span class="math notranslate nohighlight">\(1 + 4 + 5 + 3\)</span> pour trouver <span class="math notranslate nohighlight">\(13\)</span>.</p>
<p>Si ce calcul a l’air simple, il s’y cache une subtilité : nous n’avons aucun circuit auquel nous pourrions donner quatre nombres et qui en ferait la somme. Nous ne savons additionner que deux nombres à la fois. Mais nous pouvons additionner progressivement les nombres un à un à une sorte d’« accumulateur » qui stockerait les résultats intermédiaires. Au début, avant d’avoir additionné quoi que ce soit, cet accumulateur représenterait un 0. Ensuite, on y additionnerait, l’un après l’autre, chacun des nombres du calcul ainsi :</p>
<div class="math-wrapper"><div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
0 + 1 &amp;= 1 \\
1 + 4 &amp;= 5 \\
5 + 5 &amp;= 10 \\
10 + 3 &amp;= 13
\end{aligned}\end{split}\]</div></div>
<p>Chacune de ces lignes a la forme « accumulateur + nombre à additionner = nouvel accumulateur ».</p>
<p>L’avantage de procéder ainsi, en décomposant à l’extrême, est que chaque étape est une addition de précisément deux nombres — et nous savons faire de telles additions avec une ALU.</p>
<p>Commençons à créer un circuit capable de faire ceci. Notre ALU opérant sur des nombres de 4 bits, prenons le parti de représenter notre accumulateur via également 4 bits — 4 cellules mémoire, et donc 4 bascules. Pour remettre l’accumulateur à zéro, nous allons connecter un signal unique au <em>reset</em> de chacune de ces bascules. Nous allons aussi, comme chaque fois, connecter un signal d’horloge aux bascules, pour leur indiquer leur moment où elles doivent stocker les valeurs qui sont sur leurs entrées respectives. Ajoutons aussi une ALU pour effectuer l’addition et un afficheur décimal pour les 4 bits stockés dans les bascules.</p>
<p>Cela nous donne ce début de circuit, qui pour l’instant n’est pas fonctionnel :</p>
<div class="logic-container" style="height: 510px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "opts": {"showDisconnectedPins": true},
  "in": [
    {
      "pos": [340, 450],
      "orient": "n",
      "id": 40,
      "name": "Reset",
      "val": 0,
      "isPushButton": true
    },
    {
      "pos": [280, 450],
      "orient": "n",
      "id": 45,
      "name": "Horloge",
      "val": 0,
      "isPushButton": true
    }
  ],
  "components": [
    {
      "type": "alu",
      "pos": [180, 170],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, 15]
    },
    {
      "type": "flipflop-d",
      "pos": [390, 60],
      "in": [17, 18, 19, 16],
      "out": [20, 21],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 160],
      "in": [23, 24, 25, 22],
      "out": [26, 27],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 260],
      "in": [29, 30, 31, 28],
      "out": [32, 33],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 360],
      "in": [35, 36, 37, 34],
      "out": [38, 39],
      "state": 0
    }
  ],
  "out": [
    {"type": "nibble", "pos": [550, 190], "id": [46, 47, 48, 49], "name": "Acc."}
  ],
  "wires": [
    [40, 37, {"waypoints": [[340, 400]]}],
    [40, 31, {"waypoints": [[340, 300, "n"]]}],
    [40, 25, {"waypoints": [[340, 200, "n"]]}],
    [40, 19, {"waypoints": [[340, 100, "n"]]}],
    [45, 35, {"waypoints": [[280, 380]]}],
    [45, 29, {"waypoints": [[280, 280, "n"]]}],
    [45, 23, {"waypoints": [[280, 180, "n"]]}],
    [45, 17, {"waypoints": [[280, 80, "n"]]}],
    [20, 46, {"waypoints": [[480, 40]]}],
    [26, 47, {"waypoints": [[480, 140]]}],
    [32, 48, {"waypoints": [[480, 240]]}],
    [38, 49, {"waypoints": [[480, 340]]}]
  ]
}
</script></logic-editor></div><p>Connectons maintenant les entrées de l’ALU. On se rappelle qu’à chaque étape, l’ALU calculera une addition de la forme « accumulateur + nombre à additionner = nouvel accumulateur ». L’entrée <span class="math notranslate nohighlight">\(A\)</span> de l’ALU est la valeur de l’accumulateur, donc ce qui est stocké par nos bascules. On connecte donc la sortie <span class="math notranslate nohighlight">\(Q\)</span> de chaque bascule vers le bit d’entrée <span class="math notranslate nohighlight">\(A\)</span> correspondant de l’ALU.</p>
<p>L’entrée <span class="math notranslate nohighlight">\(B\)</span> de l’ALU est le nouveau nombre à additionner. Pour cela, nous ajoutons simplement quatre entrées normales, ainsi qu’un afficheur décimal pour nous simplifier la lecture du nombre représenté par ces entrées :</p>
<div class="logic-container" style="height: 550px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "opts": {"showDisconnectedPins": true},
  "in": [
    {
      "pos": [340, 490],
      "orient": "n",
      "id": 40,
      "name": "Reset",
      "val": 0,
      "isPushButton": true
    },
    {"pos": [40, 220], "id": 41, "val": 0},
    {"pos": [40, 250], "id": 42, "val": 0},
    {"pos": [40, 280], "id": 43, "val": 0},
    {"pos": [40, 310], "id": 44, "val": 0},
    {
      "pos": [280, 490],
      "orient": "n",
      "id": 45,
      "name": "Horloge",
      "val": 0,
      "isPushButton": true
    }
  ],
  "out": [
    {
      "type": "nibble",
      "pos": [100, 390],
      "orient": "s",
      "id": [50, 51, 52, 53],
      "name": "B"
    },
    {"type": "nibble", "pos": [550, 230], "id": [46, 47, 48, 49], "name": "Acc."}
  ],
  "components": [
    {
      "type": "alu",
      "pos": [180, 210],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, 15]
    },
    {
      "type": "flipflop-d",
      "pos": [390, 100],
      "in": [17, 18, 19, 16],
      "out": [20, 21],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 200],
      "in": [23, 24, 25, 22],
      "out": [26, 27],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 300],
      "in": [29, 30, 31, 28],
      "out": [32, 33],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 400],
      "in": [35, 36, 37, 34],
      "out": [38, 39],
      "state": 0
    }
  ],
  "wires": [
    [40, 37, {"waypoints": [[340, 440]]}],
    [40, 31, {"waypoints": [[340, 340, "n"]]}],
    [40, 25, {"waypoints": [[340, 240, "n"]]}],
    [40, 19, {"waypoints": [[340, 140, "n"]]}],
    [20, 0, {"waypoints": [[430, 80], [430, 50], [130, 50], [130, 130]]}],
    [26, 1, {"waypoints": [[440, 180], [440, 40], [120, 40], [120, 150]]}],
    [32, 2, {"waypoints": [[450, 280], [450, 30], [110, 30], [110, 170]]}],
    [38, 3, {"waypoints": [[460, 380, "n"], [460, 20], [100, 20], [100, 190]]}],
    [41, 4],
    [42, 5],
    [43, 6],
    [44, 7],
    [45, 35, {"waypoints": [[280, 420]]}],
    [45, 29, {"waypoints": [[280, 320, "n"]]}],
    [45, 23, {"waypoints": [[280, 220, "n"]]}],
    [45, 17, {"waypoints": [[280, 120, "n"]]}],
    [41, 50],
    [42, 51],
    [43, 52],
    [44, 53],
    [20, 46, {"waypoints": [[480, 80]]}],
    [26, 47, {"waypoints": [[480, 180]]}],
    [32, 48, {"waypoints": [[480, 280]]}],
    [38, 49, {"waypoints": [[480, 380]]}]
  ]
}
</script></logic-editor></div><p>Il reste à connecter la sortie <span class="math notranslate nohighlight">\(S\)</span> de l’ALU. Cette sortie nous livre la prochaine valeur à stocker dans l’accumulateur, et nous pouvons ainsi la connecter aux quatre entrées <span class="math notranslate nohighlight">\(D\)</span> des bascules.</p>
<p>Voici le circuit final :</p>
<div class="logic-container" style="height: 550px;"><logic-editor mode="tryout">
<script type="application/json">
{
  "v": 1,
  "in": [
    {
      "pos": [340, 490],
      "orient": "n",
      "id": 40,
      "name": "Reset",
      "val": 0,
      "isPushButton": true
    },
    {"pos": [40, 220], "id": 41, "val": 0},
    {"pos": [40, 250], "id": 42, "val": 0},
    {"pos": [40, 280], "id": 43, "val": 0},
    {"pos": [40, 310], "id": 44, "val": 0},
    {
      "pos": [280, 490],
      "orient": "n",
      "id": 45,
      "name": "Horloge",
      "val": 0,
      "isPushButton": true
    }
  ],
  "out": [
    {
      "type": "nibble",
      "pos": [100, 390],
      "orient": "s",
      "id": [50, 51, 52, 53],
      "name": "B"
    },
    {"type": "nibble", "pos": [550, 230], "id": [46, 47, 48, 49], "name": "Acc."}
  ],
  "components": [
    {
      "type": "alu",
      "pos": [180, 210],
      "in": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
      "out": [10, 11, 12, 13, 14, 15]
    },
    {
      "type": "flipflop-d",
      "pos": [390, 100],
      "in": [17, 18, 19, 16],
      "out": [20, 21],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 200],
      "in": [23, 24, 25, 22],
      "out": [26, 27],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 300],
      "in": [29, 30, 31, 28],
      "out": [32, 33],
      "state": 0
    },
    {
      "type": "flipflop-d",
      "pos": [390, 400],
      "in": [35, 36, 37, 34],
      "out": [38, 39],
      "state": 0
    }
  ],
  "wires": [
    [10, 16, {"waypoints": [[260, 80]]}],
    [11, 22, {"waypoints": [[260, 180]]}],
    [12, 28, {"waypoints": [[260, 280]]}],
    [13, 34, {"waypoints": [[260, 380]]}],
    [40, 37, {"waypoints": [[340, 440]]}],
    [40, 31, {"waypoints": [[340, 340, "n"]]}],
    [40, 25, {"waypoints": [[340, 240, "n"]]}],
    [40, 19, {"waypoints": [[340, 140, "n"]]}],
    [20, 0, {"waypoints": [[430, 80], [430, 50], [130, 50], [130, 130]]}],
    [26, 1, {"waypoints": [[440, 180], [440, 40], [120, 40], [120, 150]]}],
    [32, 2, {"waypoints": [[450, 280], [450, 30], [110, 30], [110, 170]]}],
    [38, 3, {"waypoints": [[460, 380, "n"], [460, 20], [100, 20], [100, 190]]}],
    [41, 4],
    [42, 5],
    [43, 6],
    [44, 7],
    [45, 35, {"waypoints": [[280, 420]]}],
    [45, 29, {"waypoints": [[280, 320, "n"]]}],
    [45, 23, {"waypoints": [[280, 220, "n"]]}],
    [45, 17, {"waypoints": [[280, 120, "n"]]}],
    [41, 50],
    [42, 51],
    [43, 52],
    [44, 53],
    [20, 46, {"waypoints": [[480, 80]]}],
    [26, 47, {"waypoints": [[480, 180]]}],
    [32, 48, {"waypoints": [[480, 280]]}],
    [38, 49, {"waypoints": [[480, 380]]}]
  ]
}
</script></logic-editor></div><p>Ce circuit fonctionne ainsi : au début du calcul, on réinitialise les bascules à zéro avec le signal <span class="math notranslate nohighlight">\(Reset\)</span>. Ensuite, on compose le prochain nombre à additionner sur l’entrée <span class="math notranslate nohighlight">\(B\)</span>. L’ALU va calculer immédiatement la somme <span class="math notranslate nohighlight">\(A + B\)</span>, mais ce n’est qu’au prochain coup d’horloge que cette somme sera stockée dans les bascules et apparaîtra ainsi à droite. Après avoir donné ce coup d’horloge, donc, on pourra à nouveau composer sur l’entrée <span class="math notranslate nohighlight">\(B\)</span> le prochain nombre à additionner, et ainsi de suite.</p>
<p>On réalise ici l’importance du coup d’horloge : si les bascules stockaient immédiatement la valeur livrée par l’ALU sans attendre le coup d’horloge, on retrouverait presque sans délai cette valeur sur la sortie des bascules et donc… à l’entrée <span class="math notranslate nohighlight">\(A\)</span> de l’ALU, qui recalculerait immédiatement la somme de cette valeur et de l’entrée <span class="math notranslate nohighlight">\(B\)</span>, livrerait le résultat sur la sortie vers les bascules, qui feraient à nouveau la propagation immédiate de ceci sur leurs sorties et sur l’entrée <span class="math notranslate nohighlight">\(A\)</span> de l’ALU, etc. — le système s’emballerait. Le signal d’horloge veille à ce que l’opération de stockage et de propagation soit coordonnée et se passe au bon moment.</p>
<div class="admonition-exercice-9-additions-avec-bascules admonition">
<p class="admonition-title">Exercice 9 : additions avec bascules</p>
<p>Suivez la procédure décrite ci-dessus pour effectuer l’addition <span class="math notranslate nohighlight">\(1 + 4 + 5 + 3 = 13\)</span>.</p>
</div>
<!-- TODO avons-nous besoin de cet exercice?
`````{admonition} Exercice 10 : bit de dépassement
Un problème avec le circuit actuel est qu'en cas de dépassement de capacité, (décrire problème du carry, comment s'en souvenir? circuit à modifier)

ajouter circuit de départ, mêne qu'en haut mais modifiable

````{dropdown} Corrigé
La solution consiste à stocker aussi le bit de dépassement $V$ au sortir de l'ALU à chaque coup d'horloge. Pour cela, il nous faut ajouter une nouvelle bascule, dont l'entrée récupère la sortie $V$ de l'ALU et dont l'horloge et le _reset_ dont les mêmes signaux que pour les autres bascules.

montrer circuit corrigé
````
`````
-->
</section>
</section>
<section id="recapitulatif">
<h2>Récapitulatif<a class="headerlink" href="#recapitulatif" title="Lien permanent vers ce titre">¶</a></h2>
<p>Au cours des trois chapitres précédents, nous avons vu comment les portes logiques sont utilisées comme composants de base des ordinateurs. Nous avons d’abord exploré des portes simples comme <strong>OU</strong> et <strong>ET</strong>, puis montré comment ces portes peuvent être combinées en systèmes logiques plus complexes.</p>
<p>Avec des portes, nous avons construit un additionneur de deux bits. Nous avons ensuite été à même, en enchaînant plusieurs additionneurs, de créer un système qui peut additionner non pas simplement deux bits, mais deux nombres entiers codés sur 4 bits chacun.</p>
<p>Nous avons ensuite découvert l’unité arithmétique et logique, capable de réaliser plusieurs opérations différentes avec ses entrées en fonction de bits supplémentaires qui permettent de sélectionner l’opération à effectuer.</p>
<p>Notre dernière étape d’exploration des systèmes logiques nous a menés aux verrous et aux bascules, des composants pensés pour stocker des bits de données et ainsi constituer des cellules de mémoire pour l’ordinateur. Nous avons enfin été capables, avec une ALU et une série de bascules, d’additionner à la chaîne plusieurs nombres, en nous rappelant les résultats des additions intermédiaires.</p>
<p>Il existe bien d’autres éléments qui composent les ordinateurs et nous n’avons pas l’occasion de tous les explorer en détail. Dans la section qui suit, faisons un saut conceptuel et parlons de l’architecture générale des ordinateurs et de la manière dont les grands composants sont interconnectés pour permettre à un ordinateur de remplir les fonctions que nous lui connaissons.</p>
<details class="sphinx-bs dropdown card mb-3">
<summary class="summary-title card-header">
Jeu pour aller plus loin<div class="summary-down docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-down" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z" fill-rule="evenodd"></path></svg></div>
<div class="summary-up docutils">
<svg aria-hidden="true" class="octicon octicon-chevron-up" height="24" version="1.1" viewbox="0 0 24 24" width="24"><path d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z" fill-rule="evenodd"></path></svg></div>
</summary><div class="summary-content card-body docutils">
<p class="card-text">Dans le jeu en ligne « Nandgame » (<a class="reference external" href="https://nandgame.com">https://nandgame.com</a>), on construit petit à petit un ordinateur complet juste avec, à la base, des portes <strong>NON-ET</strong>. Elles sont la particularité (avec les portes <strong>NON-OU</strong>, d’ailleurs) de pouvoir simuler toutes les autres portes — y compris un inverseur.</p>
</div>
</details><hr class="footnotes docutils"/>
<dl class="footnote brackets">
<dt class="label" id="flipflop"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Il y a une différence conceptuelle fondamentale entre les verrous et les bascules : les verrous sont des composants dits <em>asynchrones</em>, dont l’état peut changer dès qu’une des entrées change, alors que les bascules sont des composants dits <em>synchrones</em>, qui ont une entrée appelée Horloge, et dont l’état ne changera qu’au moment où le signal d’horloge effectuera une transition (dans notre cas, passera de 0 à 1). Une discussion plus poussée de ces différences dépasse le cadre de ce cours.</p>
</dd>
</dl>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="archi-gen.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title"><span class="section-number">5. </span>Architecture générale et composants</div>
              </div>
              <svg><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="additionneur.html">
              <svg><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title"><span class="section-number">3. </span>Additionneur</div>
                
              </div>
            </a>
        </div>

        <div class="related-information">
              Copyright &#169; CC-BY-NC |
            Built with <a href="https://www.sphinx-doc.org/">Sphinx</a>
              and
              <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
              <a href="https://github.com/pradyunsg/furo">Furo theme</a>. |
            <a class="muted-link" href="../_sources/archi/alu-mem.md.txt"
               rel="nofollow">
              Montrer le code source
            </a>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            Contenu
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">4. ALU et mémoire</a><ul>
<li><a class="reference internal" href="#unite-arithmetique-et-logique">Unité arithmétique et logique</a><ul>
<li><a class="reference internal" href="#selection-de-loperation">Sélection de l’opération</a></li>
<li><a class="reference internal" href="#une-alu-a-4-bits">Une ALU à 4 bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#memoire">Mémoire</a><ul>
<li><a class="reference internal" href="#le-verrou-sr">Le verrou SR</a></li>
<li><a class="reference internal" href="#la-bascule-d">La bascule D</a></li>
<li><a class="reference internal" href="#addition-en-plusieurs-etapes">Addition en plusieurs étapes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recapitulatif">Récapitulatif</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/scripts/main.js"></script>
    <script src="../_static/glossary.js"></script>
    <script src="../_static/questions.js"></script>
    <script src="https://logic.modulo-info.ch/simulator/lib/bundle.js"></script>
    <script src="../_static/blanks.js"></script>
    <script src="../_static/timeline.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="../_static/scripts/reactions.js"></script>
    <script src="../_static/scripts/progress.js"></script>
    <script src="../_static/scripts/dark.js"></script>
    <script src="../_static/scripts/frames.js"></script>
    </body>
</html>